# React Router v7 RSC Dashboard Template - Cursor Rules

## Project Overview

React Router v7 RSC (React Server Components) dashboard template with authentication, TypeScript, TailwindCSS v4, daisyUI v5, Drizzle ORM, and PostgreSQL.

## Core Technologies

- **Framework**: React 19 + React Router v7 with RSC
- **Language**: TypeScript (strict mode)
- **Styling**: TailwindCSS v4 + daisyUI v5
- **Database**: PostgreSQL + Drizzle ORM
- **Build**: Vite
- **Package Manager**: pnpm

## File Structure & Naming Conventions

### Directory Structure

```
src/
├── actions/           # Server actions (auth, etc.)
├── components/        # Reusable UI components
├── db/               # Database layer
│   ├── mutations/    # Database write operations
│   ├── queries/      # Database read operations
│   └── schema.ts     # Database schema definitions
├── lib/              # Utility functions and shared logic
├── routes/           # File-based routing
└── entry.*.tsx       # RSC entry points (DO NOT MODIFY)
```

### File Naming

- **Routes**: `route.tsx` for pages, `client.tsx` for client components
- **Components**: kebab-case (e.g., `auth-forms.tsx`, `global-loader.tsx`)
- **Utilities**: kebab-case (e.g., `utils.ts`, `session.ts`)

## Code Style & Conventions

### TypeScript

- Always use strict TypeScript
- Prefer explicit types for function parameters and return values
- Use `type` for object shapes, `interface` for extensible contracts
- Export types using `export type` syntax
- Database types: Use Drizzle's `$inferSelect` and `$inferInsert`

```typescript
// Good
export type User = typeof users.$inferSelect;
export type NewUser = typeof users.$inferInsert;

export async function getUserById(
  db: Database,
  id: string
): Promise<User | undefined> {
  // ...
}
```

### React Patterns

#### Server Components (Default)

```typescript
// No "use client" directive needed
export default async function ServerPage() {
  const user = getUser(); // Server-side data access
  return <div>Server rendered content</div>;
}
```

#### Client Components

```typescript
"use client";

import { useState } from "react";

export function InteractiveComponent() {
  const [state, setState] = useState(false);
  return <button onClick={() => setState(!state)}>Toggle</button>;
}
```

#### Server Actions

```typescript
"use server";

import { redirect } from "react-router";

export async function serverAction(formData: FormData) {
  // Server-side logic
  redirect("/success");
}
```

### Route Structure

- Use lazy imports in `routes/config.ts`
- Middleware goes in route files as `unstable_middleware` export
- Use descriptive route IDs (e.g., "marketing.home", "app.dashboard")

```typescript
// routes/config.ts
{
  id: "app.home",
  index: true,
  lazy: () => import("./app/home/route"),
}

// routes/app/route.tsx
export const unstable_middleware = [requireUserMiddleware];

export default function AppLayout() {
  return <Outlet />;
}
```

### Database Patterns

#### Schema

- Use `pgTable` with descriptive names
- Include `createdAt` timestamps with `defaultNow()`
- Use `uuid("id").primaryKey().defaultRandom()` for IDs
- Export types using Drizzle's type inference

#### Queries (Read Operations)

- File: `db/queries/[entity].ts`
- Always accept `Database` as first parameter
- Return `Promise<Type | undefined>` for single records
- Use descriptive function names

```typescript
export async function getUserById(
  db: Database,
  id: string
): Promise<User | undefined> {
  return await db.query.users.findFirst({
    where: eq(users.id, id),
  });
}
```

#### Mutations (Write Operations)

- File: `db/mutations/[entity].ts`
- Handle errors gracefully
- Return the created/updated record when applicable

### Authentication & Session

- Use `getUser()` for optional user access
- Use `requireUser()` when user must be authenticated
- Session data structure: `{ user: { id: string } }`
- Redirect patterns: Use `validateRedirect()` utility

### Form Handling

- Use Conform + Zod for form validation
- Server actions for form submission
- Schema files: `actions/[feature]/schema.ts`
- Action files: `actions/[feature]/actions.ts`

```typescript
// Schema
export const LoginFormSchema = z.object({
  email: z.string().email(),
  password: z.string(),
});

// Component
const [lastResult, action, pending] = useActionState(login, undefined);
```

## UI & Styling

### TailwindCSS + daisyUI

- Use daisyUI components first, then Tailwind utilities
- Responsive design: Start mobile-first, use `sm:`, `md:`, `lg:` prefixes
- Layout pattern: `max-w-screen-xl mx-auto px-4` for main containers
- Use semantic daisyUI colors: `primary`, `secondary`, `base-100`, etc.

### Component Structure

```typescript
// Good structure
export function ComponentName() {
  return (
    <div className="max-w-screen-xl mx-auto px-4">
      <header className="navbar bg-base-200">{/* Navigation */}</header>
      <main className="grid gap-6">{/* Content */}</main>
    </div>
  );
}
```

### Common Patterns

- Loading states: `<span className="loading loading-dots loading-md" />`
- Buttons: `btn btn-primary`, `btn btn-ghost`, etc.
- Forms: Use `floating-label` for inputs
- Modals: Use HTML dialog element with daisyUI classes
- Grid layouts: `grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3`

## Error Handling

### Client-Side

- Use Error Boundaries in route files. ErrorBoundary's must be client components to access the error with `useRouteError()`

```typescript
export function ErrorBoundary() {
  return (
    <div className="alert alert-error">
      <span>Something went wrong!</span>
    </div>
  );
}
```

### Server-Side

- Use `assert()` utility for critical checks
- Return appropriate error responses in actions via the `submission.reply({ hideFields: ["password"], resetForm: false })`
- Validate redirects with `validateRedirect()`

## Import Conventions

### Path Aliases

- `@/` maps to `src/`
- Always use absolute imports for src files

```typescript
// Good
import { getUser } from "@/lib/auth";
import { LoginForm } from "@/components/auth-forms";

// Avoid relative imports for src files
import { getUser } from "../lib/auth"; // Don't do this

import { Component } from "./client"; // This is ok
```

### Import Order

1. Node builtins
2. External libraries (React, etc.)
3. `@/` imports
4. Relative imports (if any)

```typescript
import * as path from "node:path";

import { useState } from "react";
import { redirect } from "react-router";

import { getUser } from "@/lib/auth";
import { Button } from "@/components/ui/button";

import { localUtility } from "./utils";
```

## Security & Performance

### Authentication

### Database

- Use parameterized queries (Drizzle handles this)
- Validate all inputs with Zod v4 schemas
- Use transactions for related operations

### Performance

- Lazy load routes in `config.ts`
- Use React Server Components by default
- Only use "use client" when necessary for interactivity

## Testing & Development

### TypeScript

- Run `pnpm typecheck` before commits
- Fix all TypeScript errors, no `any` types
- Use strict mode settings

### Development Commands

- `pnpm dev` - Development server
- `pnpm build` - Production build
- `pnpm typecheck` - Type checking

## Anti-Patterns to Avoid

❌ **Don't modify entry files** (`entry.*.tsx`) - these are pre-configured for RSC
❌ **Don't use relative imports** for src files - use `@/` alias instead
❌ **Don't use non-semantic colors** - prefer daisyUI color names over Tailwind colors
❌ **Don't create custom CSS** - use Tailwind + daisyUI utilities
❌ **Don't ignore TypeScript errors** - fix them immediately

## Quick Reference

### New Component

```typescript
"use client";

import { getFormProps, getInputProps, useForm } from "@conform-to/react";
import { parseWithZod } from "@conform-to/zod/v4";
import { startTransition, useActionState } from "react";

import { login } from "@/actions/auth/actions";
import { LoginFormSchema } from "@/actions/auth/schema";
import { useSearchParams } from "react-router";

export function LoginForm() {
  const [searchParams] = useSearchParams();
  const redirectTo = searchParams.get("redirectTo") || undefined;

  const [lastResult, action, pending] = useActionState(login, undefined);

  const [form, fields] = useForm({
    lastResult,
    shouldValidate: "onBlur",
    shouldRevalidate: "onInput",
    onValidate({ formData }) {
      return parseWithZod(formData, { schema: LoginFormSchema });
    },
    onSubmit(event, { formData }) {
      startTransition(() => action(formData));
      event.preventDefault();
    },
  });

  return (
    <form {...getFormProps(form)} action={action} className="grid gap-4">
      <input type="hidden" name="redirectTo" value={redirectTo} />

      <div className="grid gap-1">
        <label className="floating-label">
          <span>Email</span>
          <input
            {...getInputProps(fields.email, { type: "email" })}
            placeholder="mail@site.com"
            autoComplete="email"
            defaultValue={form.initialValue?.email}
            className="input w-full"
          />
        </label>
        <div id={fields.email.errorId} className="text-error">
          {fields.email.errors}
        </div>
      </div>
      <div className="grid gap-1">
        <label className="floating-label">
          <span>Password</span>
          <input
            {...getInputProps(fields.password, { type: "password" })}
            placeholder="password"
            autoComplete="current-password"
            className="input w-full"
          />
        </label>
        <div id={fields.password.errorId} className="text-error">
          {fields.password.errors}
        </div>
        <div id={form.errorId} className="text-error">
          {form.errors}
        </div>
      </div>
      <div className="grid gap-1">
        <button className="btn btn-primary" type="submit">
          {pending ? (
            <span
              className="loading loading-dots loading-md"
              aria-label="Logging in...."
            />
          ) : (
            "Login"
          )}
        </button>
      </div>
    </form>
  );
}
```

### New Route

1. Create `routes/[path]/route.tsx`
2. Add to `routes/config.ts` with lazy import
3. Export default component and optional middleware

### New Database Table

1. Add to `src/db/schema.ts`
2. Export types using `$inferSelect` and `$inferInsert`
3. Create migration with Drizzle
4. Add queries and mutations as needed
